.data
fin :		.asciiz "words.txt"
prompt:		.asciiz "\nEnter word: "
nemsg:		.asciiz "Invalid word\n"
notinlist: 	.asciiz "word not in list\n"
correct:	.asciiz "Correct\n"
exitstatement: 	.asciiz "Goodbye!"
period: 	.asciiz "."
slash: 		.asciiz "/"
newline:	.asciiz "\n"

characters: 	.space 9		#creating array to store characters
input:		.space 80		#array to hold input
buffer:		.space 800000000	#array for file

.text

main:
	lb $s6, period			#period
	lb $s7, slash 			#slash
	lb $s5, newline			#new line
	
	addi $s3, $s3, 0 		#initialize counter
	la $s2, input 			#get input address
	la $s1, buffer			#get file buffer address
	
       
############################ OPEN AND READ FILE #############################################
readFile:
	#open a file 
	li   $v0, 13       # system call for open file
	la   $a0, fin      # board file name
	li   $a1, 0        # Open for reading
	li   $a2, 0
	syscall            # open a file (file descriptor returned in $v0)
	move $t1, $v0      # save the file descriptor 
	
	#read from file
	move $a0, $v0      # file descriptor 
	li   $v0, 14       # system call for read from file
	la   $a1, buffer   # address of buffer to which to read
	move $s1, $a1	   # reload buffer	
	li  $a2, 1000000
	syscall            # read from file
	
	#move $t1, $zero 	#clear file descriptor	

###############################RANDOM LETTERS############################################	
	
	la $s0, characters 		#storing it in register $s0
	
randomLetters:       
	#la $s0, characters 		#storing it in register $s0	
	li $t1, 0 			#temporary register $t0 to store counter 
loop:  li $a1, 26 #range of characters
       li $v0, 42 #random character
       syscall
       addi $a0, $a0, 97 #starting at lower case a - lower case z
       sb $a0, ($s0)
       
       addi $s0, $s0, 1 #moving to next character 
       addi $t1, $t1, 1 #incrementing counter 
       blt $t1, 9 , loop #branching through to get 9 random characters
       sb $zero, 0($s0)
       
       la $a0, characters #printing the random characters
       li $v0, 4
       syscall
       
       move $t1, $zero

######################## GET INPUT #########################################################

getInput:   
   	addi $t7, $zero, -1  #initialize input pointer
   	la $a0, prompt  #ask user to enter string
    	li $v0, 4
    	syscall

    	move $a0,$s2 #read in string
    	li $a1,50
    	li $v0,8
    	syscall
    	
 inputValidation:	
 	addi $t2, $zero, 48		#load the ascii value of 0 in $s7
	addi $t3, $zero, 49		#load the ascii value of 1 in $s6
	lb $t1, ($s2)
	beq $t2,$t1, finalExit		#if input is 0, branch to exit
	beq $t3, $t1, reset	#if input is 1, branch back to the beginning

##################### COMPARE ###############################################################
cmpLoop:
	
	addi $t7, $t7, 1		#add one to input counter
	lb $t4, ($s2)                   # get next char from str1	
	lb $t5, ($s1)                   # get next char from file
	beq $t5, $s7, slashFound	#end of file
	beq $t5, $s6, periodFound             # check if period-correct wor
	bne $t4, $t5, noMatch             # no match

	addi $s1,$s1,1                   # point to next char
    	addi $s2,$s2,1                   # point to next char
    	j cmpLoop 

slashFound:
	li $v0,4			#print not in list
	la $a0, notinlist
	syscall
	
	li $v0, 1       
	move $a0, $s3       # print score
	syscall 
	
	move $s1, $zero		#reset file buffer
	la $s1, buffer
	
	j getInput   

periodFound:
    	la $a0,correct
    	li $v0,4
    	syscall
    	
    	addi $s3, $s3, 1 #add one to total score
    	#add $a0, $zero,$zero
    	j nextInput  

nextInput:
	li $v0, 1       
	move $a0, $s3       # $integer to print
	syscall
	 
	move $s1, $zero
	la $s1, buffer
	
	j getInput
	
noMatch:
    	beq     $t5,$s6,cmpLoop             # end of string
    	
    	sub $s2, $s2, $t7 #set input address back to beginning of input string
    	addi $t7, $zero, -1 #set input counter back to zero
    	
    	j updateFileLocation
    	
updateFileLocation:
	
	addi    $s1,$s1,1	# move pointer in file buffer until it hits a period
	lb      $t5,($s1)    	# get next char from str2
	beq	$t5, $s6,ifPeriod	#if where the pointer is equal to period, go back to loop
	j updateFileLocation	#if pointer is not equal to period then loop again
	
ifPeriod:
	addi    $s1,$s1,1	# move pointer in file buffer to kove past period
	j cmpLoop
	

finalExit:	
	li $v0, 4
	la $a0, exitstatement
	syscall
	
	li $v0,10
	syscall
	
reset:
	#move $t0, $zero
	#move $s1, $zero
	#move $t2, $zero
	#move $t3, $zero
	#move $t4, $zero
	#move $t5, $zero
	#move $t7, $zero
	
	#move $s0, $zero
	#move $s2, $zero
	move $s3, $zero
	
	la $s0, characters #storing it in register $s0
       	li $t1, 0 #temporary register $t0 to store counter 
	j randomLetters

	
	
       
       
