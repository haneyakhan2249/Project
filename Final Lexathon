.data
fin :		.asciiz "words.txt"
prompt:		.asciiz "\nEnter word: "
nemsg:		.asciiz "Invalid word\n"
notinlist: 	.asciiz "word not in list\n"
correct:	.asciiz "Correct\n"
exitstatement: 	.asciiz "Goodbye!"
vowels: 	.asciiz "aeiou"

welcome:	.asciiz "Welcome to LEXATHON!!!\n"
rules:		.asciiz "\nRules:\n1. Use the letters below to make words.\n2. The words must be lowercase and between 4 and 9 alphabetic letters.\n3. Enter '1' when you want a new set of letters.\n4. Enter '0' when you want to exit the game."
stars: 		.asciiz "\n*******************************************************************************\n"

period: 	.asciiz "."
slash: 		.asciiz "/"
newline:	.asciiz "\n"

characters: 	.space 10		#creating array to store characters
input:		.space 80		#array to hold input
buffer:		.space 6000000		#array for file

.text
	
######################## MAIN #########################################################

main:
	li $v0, 4
	la $a0, stars
	syscall
	
	li $v0, 4
	la $a0, welcome
	syscall
	
	li $v0, 4
	la $a0, rules
	syscall
	
	li $v0, 4
	la $a0, stars
	syscall
	
	li $v0, 4
	la $a0, newline
	syscall

########################### OPEN AND READ FILE #############################################

readFile:
	#open a file 
	li   $v0, 13       # system call for open file
	la   $a0, fin      # board file name
	li   $a1, 0        # Open for reading
	li   $a2, 0
	syscall            # open a file (file descriptor returned in $v0)
	move $t1, $v0      # save the file descriptor 
	
	#read from file
	move $a0, $v0      # file descriptor 
	li   $v0, 14       # system call for read from file
	la   $a1, buffer   # address of buffer to which to read
	move $s1, $a1	   # reload buffer	
	li  $a2, 1000000
	syscall            # read from file
	

###############################RANDOM LETTERS############################################	
	
randomLetters:       
	la $s0, characters 		#storing it in register $s0
	li $t7, 0 			#temporary register $t0 to store counter 
	
loop:  li $a1, 26 #range of characters
       li $v0, 42 #random character
       syscall
       addi $a0, $a0, 97 #starting at lower case a - lower case z
       sb $a0, ($s0)
       
       addi $s0, $s0, 1 #moving to next character 
       addi $t7, $t7, 1 #incrementing counter 
       blt $t7, 8, loop #branching through to get 8 random characters
       sb $zero, 0($s0)
       add $t6, $zero, $zero
       addi $t1, $zero, 1
       addi $t2, $zero, 2
       addi $t3, $zero, 3
       addi $t4, $zero, 4
       addi $t5, $zero, 5
       
generateVowels:
       li $a1, 6 #range of characters
       li $v0, 42 #random character
       syscall
       move $t0, $a0
       beq $t0, $t1, addA
       beq $t0, $t2, addE
       beq $t0, $t3, addI
       beq $t0, $t4, addO
       beq $t0, $t5, addU
        
       #generating random vowels    
       addA: 
       la $s6, vowels
       lb $s7, 0($s6) 
       sb $s7, ($s0)
       j printLetters
       addE:
       la $s6, vowels
       lb $s7, 1($s6)
       sb $s7, ($s0) 
       j printLetters
       addI:
       la $s6, vowels
       lb $s7, 2($s6) 
       sb $s7, ($s0)
       j printLetters
       addO:
       la $s6, vowels
       lb $s7, 3($s6) 
       sb $s7, ($s0)
       j printLetters
       addU:
       la $s6, vowels
       lb $s7, 4($s6) 
       sb $s7, ($s0)
       j printLetters      

printLetters: 
       la $a0, characters #printing the random characters
       li $v0, 4
       syscall
       
      #Reset Register
      move $t0, $zero
      move $t1, $zero
      move $t2, $zero
      move $t3, $zero
      move $t4, $zero
      move $t5, $zero
      move $t6, $zero
      move $t7, $zero
      move $s6, $zero
      move $s7, $zero

######################## SETUP #########################################################

setup:	
	lb $s6, period			#period
	lb $s7, slash 			#slash
	lb $s5, newline			#new line
	la $s2, input 			#get input address
	move $s3, $zero

	
######################## GET INPUT #########################################################
			
getInput:   
   	addi $t7, $zero, -1  #initialize input pointer
   	la $a0, prompt  #ask user to enter string
    	li $v0, 4
    	syscall

    	move $a0,$s2 #read in string
    	li $a1,50
    	li $v0,8
    	syscall
    	
 inputValidation:	
 	addi $t2, $zero, 48		#load the ascii value of 0 in $s7
	addi $t3, $zero, 49		#load the ascii value of 1 in $s6
	lb $t1, ($s2)
	beq $t2,$t1, finalExit		#if input is 0, branch to exit
	beq $t3, $t1, reset	#if input is 1, branch back to the beginning

##################### COMPARE ###############################################################
cmpLoop:
	
	addi $t7, $t7, 1		#add one to input counter
	lb $t4, ($s2)                   # get next char from str1	
	lb $t5, ($s1)                   # get next char from file
	beq $t5, $s7, slashFound	#end of file
	beq $t5, $s6, periodFound             # check if period-correct wor
	bne $t4, $t5, noMatch             # no match

	addi $s1,$s1,1                   # point to next char
    	addi $s2,$s2,1                   # point to next char
    	j cmpLoop 

slashFound:
	li $v0,4			#print not in list
	la $a0, notinlist
	syscall
	
	li $v0, 1       
	move $a0, $s3       # print score
	syscall 
	
	move $s1, $zero		#reset file buffer
	la $s1, buffer
	
	j getInput   

periodFound:
    	la $a0,correct
    	li $v0,4
    	syscall
    	
    	addi $s3, $s3, 1 #add one to total score
    	j nextInput  

nextInput:
	li $v0, 1       
	move $a0, $s3       # $integer to print
	syscall
	 
	move $s1, $zero
	la $s1, buffer
	
	j getInput
	
noMatch:
    	beq     $t5,$s6,cmpLoop             # end of string
    	
    	sub $s2, $s2, $t7 #set input address back to beginning of input string
    	addi $t7, $zero, -1 #set input counter back to zero
    	
    	j updateFileLocation
    	
updateFileLocation:
	
	addi    $s1,$s1,1	# move pointer in file buffer until it hits a period
	lb      $t5,($s1)    	# get next char from str2
	beq	$t5, $s6,ifPeriod	#if where the pointer is equal to period, go back to loop
	j updateFileLocation	#if pointer is not equal to period then loop again
	
ifPeriod:
	addi    $s1,$s1,1	# move pointer in file buffer to kove past period
	j cmpLoop
	

finalExit:	
	li $v0, 4
	la $a0, exitstatement
	syscall
	
	li $v0,10
	syscall
	
reset:
	move $t0, $zero
	move $t1, $zero
	move $t2, $zero
	move $t3, $zero
	move $t4, $zero
	move $t5, $zero
	move $t7, $zero
	move $s6, $zero
	move $s7, $zero
	
	move $s0, $zero
	la $s0, characters #storing it in register $s0
	
	j randomLetters

	
	
       
       
